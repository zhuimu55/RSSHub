name: 'Clean up GHCR Packages'

on:
  # 每周日 UTC 00:00 执行
  schedule:
    - cron: '0 0 * * 0'
  # Docker 发布完成后自动触发
  workflow_run:
    workflows: ['Docker Release']
    types:
      - completed
  # 支持手动触发
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (preview only, no actual deletion)'
        required: false
        type: boolean
        default: true
      retention_days:
        description: 'Number of days to keep package versions'
        required: false
        type: number
        default: 30

jobs:
  cleanup:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    permissions:
      packages: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Cleanup old GHCR package versions
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'true' }}
          RETENTION_DAYS: ${{ github.event.inputs.retention_days || '30' }}
          PACKAGE_NAME: rsshub
          OWNER: ${{ github.repository_owner }}
        run: |
          set -e
          
          echo "=================================================="
          echo "GHCR Package Cleanup (Optimized)"
          echo "=================================================="
          echo "Package: ghcr.io/${OWNER}/${PACKAGE_NAME}"
          echo "Retention period: ${RETENTION_DAYS} days"
          echo "Dry run mode: ${DRY_RUN}"
          echo "=================================================="
          echo ""
          
          # 计算截止日期（UTC时间）
          if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            CUTOFF_DATE=$(date -u -v-${RETENTION_DAYS}d +%Y-%m-%dT%H:%M:%SZ)
          else
            # Linux
            CUTOFF_DATE=$(date -u -d "${RETENTION_DAYS} days ago" +%Y-%m-%dT%H:%M:%SZ)
          fi
          
          CUTOFF_TIMESTAMP=$(date -d "${CUTOFF_DATE}" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "${CUTOFF_DATE}" +%s)
          
          echo "Current time (UTC): $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Cutoff date (UTC): ${CUTOFF_DATE}"
          echo ""
          
          # 创建临时目录
          TEMP_DIR=$(mktemp -d)
          TO_DELETE_FILE="${TEMP_DIR}/to_delete.txt"
          TO_KEEP_FILE="${TEMP_DIR}/to_keep.txt"
          
          echo "Fetching package versions..."
          
          # 使用更高效的方式获取版本列表
          # 直接使用 gh 命令的 --paginate 选项
          gh api --paginate \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions" > "${TEMP_DIR}/all_versions.json" 2>/dev/null || \
          gh api --paginate \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/users/${OWNER}/packages/container/${PACKAGE_NAME}/versions" > "${TEMP_DIR}/all_versions.json"
          
          TOTAL_VERSIONS=$(jq 'length' "${TEMP_DIR}/all_versions.json")
          echo "Total versions found: ${TOTAL_VERSIONS}"
          echo ""
          
          echo "Processing versions..."
          
          # 使用 jq 一次性处理所有版本，生成待删除列表
          jq -r --arg cutoff "$CUTOFF_TIMESTAMP" '
            .[] | 
            select((.created_at | strptime("%Y-%m-%dT%H:%M:%SZ") | mktime) < ($cutoff | tonumber)) |
            .id
          ' "${TEMP_DIR}/all_versions.json" > "$TO_DELETE_FILE"
          
          # 生成保留列表
          jq -r --arg cutoff "$CUTOFF_TIMESTAMP" '
            .[] | 
            select((.created_at | strptime("%Y-%m-%dT%H:%M:%SZ") | mktime) >= ($cutoff | tonumber)) |
            .id
          ' "${TEMP_DIR}/all_versions.json" > "$TO_KEEP_FILE"
          
          DELETED_COUNT=$(wc -l < "$TO_DELETE_FILE" | tr -d ' ')
          KEPT_COUNT=$(wc -l < "$TO_KEEP_FILE" | tr -d ' ')
          
          echo "=================================================="
          echo "Analysis Complete"
          echo "=================================================="
          echo "Total versions: ${TOTAL_VERSIONS}"
          echo "Versions to keep: ${KEPT_COUNT}"
          echo "Versions to delete: ${DELETED_COUNT}"
          echo ""
          
          if [[ $DELETED_COUNT -eq 0 ]]; then
            echo "✅ No versions need to be deleted."
            rm -rf "$TEMP_DIR"
            exit 0
          fi
          
          # 显示一些样本
          echo "Sample of versions to delete:"
          head -n 10 "$TO_DELETE_FILE" | while read -r version_id; do
            # 获取版本详情
            VERSION_INFO=$(jq -r --arg id "$version_id" '.[] | select(.id == $id)' "${TEMP_DIR}/all_versions.json")
            TAGS=$(echo "$VERSION_INFO" | jq -r '.metadata.container.tags[]? // empty' | tr '\n' ',' | sed 's/,$//')
            CREATED_AT=$(echo "$VERSION_INFO" | jq -r '.created_at')
            AGE_DAYS=$(( ($(date +%s) - $(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s)) / 86400 ))
            
            if [[ -n "$TAGS" ]]; then
              echo "  Version ID: ${version_id}, Tags: ${TAGS}, Age: ${AGE_DAYS} days"
            else
              echo "  Version ID: ${version_id}, Age: ${AGE_DAYS} days"
            fi
          done
          
          if [[ $DELETED_COUNT -gt 10 ]]; then
            echo "  ... and $((DELETED_COUNT - 10)) more versions"
          fi
          echo ""
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "⚠️  DRY RUN MODE - No versions were actually deleted"
            echo "   To perform actual deletion, set dry_run to false"
            rm -rf "$TEMP_DIR"
            exit 0
          fi
          
          echo "Starting batch deletion..."
          
          # 批量删除 - 使用并行处理
          BATCH_SIZE=50
          TOTAL_BATCHES=$(( (DELETED_COUNT + BATCH_SIZE - 1) / BATCH_SIZE ))
          
          echo "Processing ${DELETED_COUNT} versions in ${TOTAL_BATCHES} batches of ${BATCH_SIZE}..."
          
          # 创建批处理文件
          split -l $BATCH_SIZE "$TO_DELETE_FILE" "${TEMP_DIR}/batch_"
          
          SUCCESS_COUNT=0
          ERROR_COUNT=0
          
          for batch_file in "${TEMP_DIR}/batch_"*; do
            BATCH_NUM=$((SUCCESS_COUNT + ERROR_COUNT + 1))
            echo "Processing batch ${BATCH_NUM}/${TOTAL_BATCHES}..."
            
            # 并行删除当前批次
            while read -r version_id; do
              (
                # 尝试组织 API
                DELETE_RESULT=$(gh api \
                  --method DELETE \
                  -H "Accept: application/vnd.github+json" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions/${version_id}" 2>&1 || echo "ORG_DELETE_FAILED")
                
                # 如果组织 API 失败，尝试用户 API
                if [[ "$DELETE_RESULT" == "ORG_DELETE_FAILED" ]] || echo "$DELETE_RESULT" | grep -q "Not Found"; then
                  DELETE_RESULT=$(gh api \
                    --method DELETE \
                    -H "Accept: application/vnd.github+json" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "/users/${OWNER}/packages/container/${PACKAGE_NAME}/versions/${version_id}" 2>&1 || echo "DELETE_FAILED")
                fi
                
                if [[ "$DELETE_RESULT" == *"FAILED"* ]] || [[ -n "$DELETE_RESULT" ]]; then
                  echo "ERROR:${version_id}:${DELETE_RESULT}" >> "${TEMP_DIR}/errors.log"
                else
                  echo "SUCCESS:${version_id}" >> "${TEMP_DIR}/success.log"
                fi
              ) &
            done < "$batch_file"
            
            # 等待当前批次完成
            wait
            
            # 更新计数
            BATCH_SUCCESS=$(wc -l < "${TEMP_DIR}/success.log" 2>/dev/null || echo "0")
            BATCH_ERROR=$(wc -l < "${TEMP_DIR}/errors.log" 2>/dev/null || echo "0")
            
            echo "  Batch ${BATCH_NUM} completed. Success: ${BATCH_SUCCESS}, Errors: ${BATCH_ERROR}"
          done
          
          # 最终统计
          FINAL_SUCCESS=$(wc -l < "${TEMP_DIR}/success.log" 2>/dev/null || echo "0")
          FINAL_ERROR=$(wc -l < "${TEMP_DIR}/errors.log" 2>/dev/null || echo "0")
          
          echo ""
          echo "=================================================="
          echo "Cleanup Complete"
          echo "=================================================="
          echo "Total versions processed: ${TOTAL_VERSIONS}"
          echo "Versions kept: ${KEPT_COUNT}"
          echo "Versions successfully deleted: ${FINAL_SUCCESS}"
          echo "Versions failed to delete: ${FINAL_ERROR}"
          
          if [[ $FINAL_ERROR -gt 0 ]]; then
            echo ""
            echo "Errors encountered:"
            head -n 10 "${TEMP_DIR}/errors.log"
            if [[ $FINAL_ERROR -gt 10 ]]; then
              echo "... and $((FINAL_ERROR - 10)) more errors"
            fi
          fi
          
          echo "=================================================="
          
          # 清理临时文件
          rm -rf "$TEMP_DIR"
          
          # 如果有错误，退出时返回非零状态码
          if [[ $FINAL_ERROR -gt 0 ]]; then
            exit 1
          fi

